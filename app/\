[2023-05-02 08:47] @refactoring
add arguments and argument list is too long -> record might help.
some arguments is just for some constructors.

initialize mutable variables like MVar, TQueue at the beginning, like go or wrapper idiom.

sometimes I add a feature for other's program and found out I violate his princple of this program. That usually shows as s bug.

when I implement a feature but the result is not what I want.
I might need my trouble shooting to answer my own question. compare results between different version
clean debug info after fixing bugs.

when debug, there are two types of modifying code. Add debug or trying fix.
And when you fix a tiny bug, down the road become normal again.

adding imports kind of interrupt code flow
adding functions with imports like writer's block and concat imports for me
sometimes there is no bug, I just want to clean and abstract code. But something might go wrong.

sometimes I might guess wrong spot of a bug and got wrong ideas.

If it's easy to write wrong logic, maybe edsl can be improved to ensure property.

along the way, questions arise. In the process, some msytery may be solved.

go idiom can be a wrapper to make a function recursive.

If I assume right, I can fix bug or found new problems.
If I assume wrong, I can eliminate one possibility and get closer to issue.

I might encouter a crossroad where I adopt another way and leaves problems behind or keep digging.
I will find I am in a context where I would like to abandon.
Donâ€™t Assume It---Prove It

function names cannot represent what I am twisting and testing. But its a unit of testing code.

I wrote goal that may or may not be done in previous commit. Maybe I new commit and if no result, that means WIP or didn't start.

debugging is like opening a mist map.

If same goal, in same commit, if proving other guess, move to another commit. How abou that?

I think using record as argument is eaiser for refactoring

when I debug multi-thread, change an operation changes logic and cause bugs. tryRead vs trePeek. always guessing. tired of that. how to?

<$> can be used to fmap a -> b.
`fmap _hole <$>` can be sued to fmap  a -> m b

once can be used in memoize IO actions.
var username -validation IO-> var valid
should I var username and memo validation IO for SSOT? or use var valid for structural changing?

How about two streams? Does it work?
